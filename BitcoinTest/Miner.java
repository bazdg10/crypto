package BitcoinTest;
import java.io.*;
import java.math.BigInteger; 
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest; 
import java.security.NoSuchAlgorithmException; 
import java.util.*;

public class Miner { 

    private static PriorityQueue<Block> readyBlocks = new PriorityQueue<>(new BlockComparator());
    private static Queue<String> readyHashes = new LinkedList<>();

/*    public static byte[] getSHA(String input) throws NoSuchAlgorithmException
    { 
        // Static getInstance method is called with hashing SHA 
        MessageDigest md = MessageDigest.getInstance("SHA-256"); 
  
        // digest() method called 
        // to calculate message digest of an input 
        // and return array of byte
        return md.digest(input.getBytes(StandardCharsets.UTF_8)); 
    }
    
    public static String toHexString(byte[] hash)
    {
        // Convert byte array into signum representation 
        BigInteger number = new BigInteger(1, hash); 
  
        // Convert message digest into hex value 
        StringBuilder hexString = new StringBuilder(number.toString(16)); 
  
        // Pad with leading zeros
        while (hexString.length() < 32) 
        { 
            hexString.insert(0, '0'); 
        } 
  
        return hexString.toString(); 
    }
*/  
    private static HashMap<String, List<Block>> readFile() {
        System.out.println("Hola");
        String file = "../mempool1.csv";
        BufferedReader reader = null;
        String line = "";
        HashMap<String, List<Block>> blocks = new HashMap<>();
        //List<Block> blocks = new ArrayList<>();
        try {
            //int lca = 0;
            reader = new BufferedReader(new FileReader(file));
            while((line= reader.readLine())!=null) {
                String[] row = line.split(",");
                if (row.length==0 || row[0].equals("tx_id") )  continue;
                String id, fee, weight, par_id;
                id = row[0];
                fee = row[1];
                weight = row[2];
                par_id = "";
                if (row.length>3)   par_id = row[3];   
                //else    lca++;
                Block block = new Block(id, fee, weight, par_id);
                if (blocks.containsKey(par_id)) {
                    blocks.get(par_id).add(block);
                } else {
                    List<Block> b = new ArrayList<>();
                    b.add(block);
                    blocks.put(par_id, b);
                }
                //System.out.println(lca);
            }
        } catch( Exception e ) {
            e.printStackTrace();
        } finally {
            try {
                reader.close();
            } catch( Exception e ) {
                e.printStackTrace();
            }
        }
        return blocks;
    }

    private static void activateChildNode(HashMap<String, List<Block>> blocks) {
        
        while(!readyHashes.isEmpty()) {
            String hashVal = readyHashes.remove();
            if (blocks.containsKey(hashVal)) {
                for ( Block block : blocks.get(hashVal) ) {
                    readyBlocks.add(block);
                }
                blocks.remove(hashVal);
            }
        }
        return;
    }

    public static int performTransaction(Block block) {

        //try 
        //{
            //System.out.println("HashCode Generated by SHA-256 for:"); 
            String s = block.getId();
            //String s2 = block.getPar_id(); 
            //s += s2;
            //System.out.println("\n" + s1 + " : " + toHexString(getSHA(s1))); 
            readyHashes.add(s);            
            //System.out.println("\n" + s2 + " : " + toHexString(getSHA(s2))); 
            return block.getFee();
        //}
        // For specifying wrong message digest algorithms 
       /* catch (NoSuchAlgorithmException e) { 
            System.out.println("Exception thrown for incorrect algorithm: " + e); 
        }*/ 
        //return 0;
    }

    // Driver code 
    public static void main(String args[])
    {
        int netTransactionGain = 0;
        int threshold = 4000000;
        //List<Block> blocks = new ArrayList<Block>();
        HashMap<String, List<Block>> blocks = new HashMap<>();
        blocks = readFile();
        readyHashes.add("");
        int c = 0;
        while (!blocks.isEmpty()||!readyBlocks.isEmpty()) {
            if (!blocks.isEmpty())
                activateChildNode(blocks);
            List<Block> carryOut = new ArrayList<>();   
            int totWt = 0;
            while(!readyBlocks.isEmpty()) {
                Block head = readyBlocks.peek();
                if (head.getWeight()+totWt<threshold) {
                    totWt += head.getWeight();
                    carryOut.add(readyBlocks.poll());
                } else break;
            }
            
            for (Block block : carryOut) {
                netTransactionGain += performTransaction(block);
                c++;
                System.out.println(c);
                
            }
        }
         
        System.out.println(netTransactionGain);
    } 
} 


class BlockComparator implements Comparator<Block> {

    @Override
    public int compare(Block o1, Block o2) {
        return o1.getFee() - o2.getFee();
    }

} 
class Block {
    
    private int fee;
    private int weight;
    private String id;
    private String par_id;

    public Block(String id, String fee, String weight, String par_id)
    {
        this.id = id;
        this.fee = Integer.parseInt(fee);// (fee);
        this.weight = Integer.parseInt(weight);
        this.par_id = par_id;
    }
    String getId()
    {
        return id;
    }    
    String getPar_id()
    {
        return par_id;
    }
    int getFee()
    {
        return fee;
    }
    int getWeight()
    {
        return weight;
    }
}
